

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Offline Analysis TODO &mdash; ch_frb_l1  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Example Offline Analysis Scripts" href="../example_offline_analysis_scripts/index.html" />
    <link rel="prev" title="Real-Time Analysis TODO" href="real_time_analysis_todo.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ch_frb_l1
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help_my_pipeline_is_broken.html">Help! My pipeline is broken</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">TODO</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="real_time_analysis_todo.html">Real-Time Analysis TODO</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Offline Analysis TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example_offline_analysis_scripts/index.html">Example Offline Analysis Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drao/index.html">DRAO computing environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/index.html">The Real-Time L1 Server</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ch_frb_l1</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">TODO</a> &raquo;</li>
        
      <li>Offline Analysis TODO</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="offline-analysis-todo">
<h1>Offline Analysis TODO<a class="headerlink" href="#offline-analysis-todo" title="Permalink to this headline">¶</a></h1>
<p>Items marked <code class="docutils literal notranslate"><span class="pre">KMS</span></code> are things Kendrick is actively working on!</p>
<blockquote>
<div><ul>
<li><p class="first">Inventory captured data, make pulsar acquisitions.</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../example_offline_analysis_scripts/make_acq.html#making-an-acquisition"><span class="std std-ref">Making an acquisition</span></a> example script, showing how to construct an rf_pipelines stream object from a set of data files,
and serialize the stream to a json file for later use in <code class="docutils literal notranslate"><span class="pre">rfp-run</span></code>.</li>
</ul>
</div></blockquote>
<p>To determine whether there is a bright pulsar in a run, we will want to convert FPGA timestamps to real timestamps.</p>
<blockquote>
<div><ul class="simple">
<li>There is a json file which contains all the necessary information, automatically committed to git whenever the FPGA counts are reset
(<a class="reference external" href="https://github.com/CHIMEFRB/frb-configs/tree/master/RunParameters">https://github.com/CHIMEFRB/frb-configs/tree/master/RunParameters</a>).  Unfortunately it overwrites the previous file, so we need to
write a little code to loop over the git history and retrieve them all!</li>
<li>Example code: <a class="reference external" href="https://github.com/CHIMEFRB/Intensity-Analysis-Utils/blob/master/iautils/scripts/msgpack2fil.py">https://github.com/CHIMEFRB/Intensity-Analysis-Utils/blob/master/iautils/scripts/msgpack2fil.py</a>
(search for fpga_time)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Understand Miles’ framework for forecasting SNR.</p>
<blockquote>
<div><ul class="simple">
<li>Miles framework: <a class="reference external" href="https://github.com/CHIMEFRB/Sensitivity">https://github.com/CHIMEFRB/Sensitivity</a></li>
<li>ATNF catalog: <a class="reference external" href="http://www.atnf.csiro.au/people/pulsar/psrcat">http://www.atnf.csiro.au/people/pulsar/psrcat</a></li>
<li>ATNF parameter list: <a class="reference external" href="http://www.atnf.csiro.au/research/pulsar/psrcat/psrcat_help.html#par_list">http://www.atnf.csiro.au/research/pulsar/psrcat/psrcat_help.html#par_list</a></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Set up offline scripting framework for reproducing SNR values, comparing with forecasts.</p>
<p>Roughly, the chain of steps might look like this:</p>
<blockquote>
<div><ul>
<li><p class="first">Make an rf_pipelines stream object and serialize it to a json file.
See the <a class="reference internal" href="../example_offline_analysis_scripts/make_acq.html#making-an-acquisition"><span class="std std-ref">Making an acquisition</span></a> example script, although you’ll want to use more data!  (The example
script only uses 10 data files, i.e. 10 seconds of data.)</p>
</li>
<li><p class="first">Choose a RFI transform chain.  There are some json-serialized RFI chains in the <a class="reference external" href="https://github.com/mrafieir/ch_frb_rfi">mrafieir/ch_frb_rfi</a> repo.
In this example, I’ll use <code class="docutils literal notranslate"><span class="pre">ch_frb_rfi/json_files/rfi_16k/17-12-02-two-pass-v3.json</span></code>, which also contains
some plotter transforms for the web viewer.</p>
</li>
<li><p class="first">Make a bonsai transform and serialize it to json.  There are some json-serialized bonsai transforms in <a class="reference external" href="https://github.com/mrafieir/ch_frb_rfi">mrafieir/ch_frb_rfi</a>,
but let’s make a new transform, so that we can write the output of the dedispersion transform to an hdf5 file for later
processing.  See the <a class="reference internal" href="../example_offline_analysis_scripts/make_jsonized_bonsai_transform.html#making-a-bonsai-transform"><span class="std std-ref">Making a bonsai transform</span></a> example script.</p>
</li>
<li><p class="first">Run the “stream -&gt; rfi -&gt; bonsai” pipeline with the <code class="docutils literal notranslate"><span class="pre">rfp-run</span></code> utility (which is part of rf_pipelines):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="c1"># Type &#39;rfp-run&#39; with no arguments for a list of all its command-line options.</span>

<span class="n">rfp</span><span class="o">-</span><span class="n">run</span> <span class="o">-</span><span class="n">w</span> <span class="n">example</span> \    <span class="c1"># name of run for web viewer</span>
  <span class="n">example_acq</span><span class="o">.</span><span class="n">json</span> \      <span class="c1"># first in pipeline: stream</span>
  <span class="n">ch_frb_rfi</span><span class="o">/</span><span class="n">json_files</span><span class="o">/</span><span class="n">rfi_16k</span><span class="o">/</span><span class="mi">17</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="n">two</span><span class="o">-</span><span class="k">pass</span><span class="o">-</span><span class="n">v3</span><span class="o">.</span><span class="n">json</span>   <span class="c1"># second: RFI chain</span>
  <span class="n">example_bonsai_transform</span><span class="o">.</span><span class="n">json</span>     <span class="c1"># last in pipeline: dedisperser</span>
</pre></div>
</div>
<p>Depending on how long your stream is, this may take a while to run.  You may want to use <code class="docutils literal notranslate"><span class="pre">screen</span></code> or <code class="docutils literal notranslate"><span class="pre">tmux</span></code> to run the command above.</p>
<p>After the pipeline run ends, there should be an entry in the web viewer, containing waterfall and trigger plots.
(For information on the web viewer, see <a class="reference internal" href="../drao/web_services.html#web-services"><span class="std std-ref">Web Services</span></a>.)</p>
<p>There should also be a large HDF5 file containing bonsai’s output arrays during the run.  We can postprocess
this file to determine the SNR of each pulse.</p>
</li>
<li><p class="first">Another option for determining the pulsar SNR would be to figure out how to use Alex Josephy’s “L1B” code,
a real-time tool which runs in the pipeline, postprocesses the bonsai output arrays, and generates an event list.</p>
</li>
<li><p class="first">At some point we should figure out how to query the SQL database to figure out what SNR values
were reported by the real-time pipeline.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">KMS</span></code>: the bonsai HDF5 file format currently isn’t documented anywhere!  I’ll do this soon.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">KMS</span></code>: the bonsai HDF5 file should get written to the web viewer directory (or pipeline rundir).
Currently it gets written to the current working directory when the pipeline is run.
This is a recipe for different runs overwriting each other and creating confusion!</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">More work on detrending.  Here is one possible reason why our reported SNR for pulsars might be low.
Our RFI removal chain includes a “detrender” (i.e. fitting and subtracting a slowly varying baseline) along the
frequency axis of the (frequency, time) array.  This removes a fraction of the SNR, which will depend on the parameters
of the pulse.</p>
<p>In the memo <a class="reference download internal" download="" href="../_downloads/838a5ad4c48e055e0b1e81b1424e1f04/18-03-19-pulsar-snr.pdf"><code class="xref download docutils literal notranslate"><span class="pre">18-03-19-pulsar-snr.pdf</span></code></a>, we made an initial study of this
effect and found that the fractional SNR loss was a simple function of (pulse DM) / (pulse width).  For typical FRB
parameters, the SNR loss is small, but for pulsars it can be very significant.</p>
<p>Does this effect completely or partially explain our low reported SNR’s?</p>
<p>This effect can be reduced substantially by changing a parameter in the RFI removal pipeline (the degree of the polynomial
fit that we use in the detrender).  We should definitely be doing this for pulsars, and maybe for the real-time FRB search.
What is the lowest polynomial degree we can “get away with” without getting a lot of false positives from RFI?</p>
<p>Update: Masoud has a new RFI chain with less detrending.  We should revisit the SNR study and see how much of a difference
this makes.</p>
<p>The SNR study was done using the <a class="reference external" href="https://github.com/kmsmith137/frb_olympics">frb_olympics</a> code.</p>
<p>Some notes are available here:
<a class="reference external" href="https://github.com/kmsmith137/frb_olympics/tree/master/examples/example2_rf_pipelines">https://github.com/kmsmith137/frb_olympics/tree/master/examples/example2_rf_pipelines</a></p>
</li>
<li><p class="first">Overclipping studies.  Here is another possible reason our reported SNR for pulsars might be low.
We usually study bright pulsars, where the pulses may be mistaken for RFI and masked by the “clipper” transforms
in our RFI removal chain.</p>
<p>Is this happening?  If so, how should we modify our RFI transform chain so that we avoid overclipping bright pulsars,
while still removing most of the RFI?  (Reminder: we don’t need to use the same RFI transform chain for postprocessing
pulsars as we do in the real-time search.)</p>
</li>
<li><p class="first">I like the following idea for a quick hack to test whether we’re overclipping bright pulsars.</p>
<p>We write a new transform which <em>overwrites</em> the data array with 0 or 1, depending on whether the data element
is unmasked or masked (i.e. the complement of the mask array), and sets the mask array to all ones.  We put this
transform after RFI removal and before dedispersion.
Then if we see the pulsar in the output of the dedispersion transform, we’ll know that we’re overclipping.</p>
<p><code class="docutils literal notranslate"><span class="pre">KMS</span></code>: will add an example script showing how to write a new rf_pipelines transform in python.</p>
</li>
<li><p class="first">Simulating a pulsar.  Are bonsai’s SNR estimates still unbiased if pulses are repeating (rather than isolated)?</p>
<p>Here is something we should have done a long time ago!  The variance estimation logic in bonsai assumes that
pulses are isolated (as expected for FRB’s).  It has never been tested on a simulated pulsar, with regularly
repeating pulses at the same DM.  We should do a quick simulation study to check whether bonsai’s SNR estimates
are still unbiased in this case.</p>
<p>Here is an example script showing how to inject a simulated pulse into a pipeline run: <a class="reference internal" href="../example_offline_analysis_scripts/injecting_pulse.html#injecting-a-simulated-pulse"><span class="std std-ref">Injecting a simulated pulse</span></a>.</p>
<p>This script should be hackable to inject a simulated pulsar (using a long chain of frb_injector_transforms, this approach will
waste some CPU time but should be fine for a one-time study!)</p>
</li>
<li><p class="first">Channel weighting.  Here is an important topic that we will be working on for a while!</p>
<p>Currently, bonsai assigns equal weight to each frequency channel.  The optimal weighting would be to
weight frequency channel “i” by (s_i / v_i), where s_i is the frequency spectrum of the pulsar (i.e.
the strength of the pulsar in channel i), and v_i is the variance of channel i.</p>
<p>We don’t know how much the quantity (s_i / v_i) varies from channel to channel, so we don’t know
how suboptimal our current weighting is!</p>
<p>There is already a <code class="docutils literal notranslate"><span class="pre">VarianceEstimator</span></code> class in rf_pipelines, so we should be able to use that
to get estimates for v_i.</p>
<p>Getting estimates for s_i is harder and will require significant new code!  It helps a lot that
we know the period and dispersion measure of the pulsar in advance.</p>
<p><code class="docutils literal notranslate"><span class="pre">KMS</span></code>: will add an example script showing how to use the VarianceEstimator.</p>
</li>
<li><p class="first">Some low-level data quality studies that don’t require running the pipeline!</p>
<p>Is the radiometer equation satisfied?  The radiometer equation states that the variance V
of the sampled intensity data is related to its mean value by V = (2/N) I^2, where N is the number
of channelized electric field values which contribute to a sample.  (I believe N=96 for CHIME but
I need to double-check!)</p>
<p>The radiometer equation always applies if the intensity samples are formed by summing the squares
of N uncorrelated Gaussian electric field samples, even if the weighting used to obtain those
samples is suboptimal.  So if we see large deviations from the radiometer equation, then something
is seriously wrong “upstream” from the FRB search backend!</p>
<p>Is quantization noise an issue?  This should be an easy question to answer, we can just compute the
variance of each channel (with median filtering to remove RFI) and check that it is significantly
larger than the quantization scale.</p>
<p>The following example script may be useful: <a class="reference internal" href="../example_offline_analysis_scripts/reading_msgpack_file.html#reading-a-msgpack-file"><span class="std std-ref">Reading a msgpack file</span></a>.</p>
</li>
<li><p class="first">If we end up finding it difficult to write an RFI transform chain which avoids overclipping bright pulsars,
here is an idea which may be helpful.</p>
<p>We can write a pair of transforms, the <code class="docutils literal notranslate"><span class="pre">pulsar_masker</span></code> and <code class="docutils literal notranslate"><span class="pre">pulsar_unmasker</span></code>, which respectively mask
pulses from a known pulsar, and undo this masking.  Then we can use a weaker level of RFI removal for data
in pulses than for data outside pulses.  This would be implemented by applying the pulsar_masker, then applying
“strong” RFI removal, then the pulsar_unmasker, then “weak” RFI removal.</p>
<p>For this to work, we would need to know the arrival times of the pulses, which is a mini-project in itself!
Are our timestamps good enough to get this information (the pulsar “ephemeris”) from external sources?
Or do we need to infer the arrival time directly from the data, by running a simplified pulsar search code?</p>
</li>
</ul>
</div></blockquote>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../example_offline_analysis_scripts/index.html" class="btn btn-neutral float-right" title="Example Offline Analysis Scripts" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="real_time_analysis_todo.html" class="btn btn-neutral" title="Real-Time Analysis TODO" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>